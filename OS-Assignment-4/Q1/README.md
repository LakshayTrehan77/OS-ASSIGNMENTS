# CONTRIBUTORS
1. LAKSHAY TREHAN (2022267)
2. NISHANT SINGH (2022595)

# DINING PHILOSOPHERS PROBLEM

## INTRODUCTION

### AIM OF THE QUESTION
IN THIS QUESTION, WE HAVE TO MODIFY THE DINING PHILOSOPHERS PROBLEM SUCH THAT IT ALSO DEALS AND INCLUDES THE CASE OF BOWLS USING THREADS. WHEN THE PHILOSOPHERS PERFORM TASKS LIKE EATING, THINKING, ETC., THE CASE OF DEADLOCK SHOULD NOT OCCUR.

### TASKS THAT WE ARE SUPPOSED TO PERFORM ARE:
1. WE HAVE TO MODIFY THE PHILOSOPHERS PROBLEM SUCH THAT IT INCLUDES 2 BOWLS AND 5 FORKS
2. WE HAVE TO PROGRAM AND DESIGN THE THREADS OF PHILOSOPHERS SUCH THAT EACH PERFORMS THE EATING AND THINKING TASKS
3. WE HAVE TO SHOW THE USE OF THE FOLLOWING FUNCTIONS IN THE CODE:

    - void* philosopher(void* args) : it is responsible for running the philosopher's thread
    - void eating() : it is responsible for entering the eating state
    - void thinking() : it is responsible for entering the thinking state

4. WE HAVE TO USE MUTEXES AND CONDITIONAL VARIABLES IN SOLVING THE PROBLEM.

## DEADLOCK
THE SITUATION OF DEADLOCK OCCURS WHEN A PROCESS WAITS FOR THE RESOURCE(S), THAT ARE CURRENTLY BEING USED BY SOME OTHER PROCESS TO PERFORM THE FINAL TASK.

## WHY DEADLOCKS OCCUR IN ANY PROBLEM?
IN ANY CODE, THE CASES WHERE DEADLOCKS CAN OCCUR ARE:

    - THE PROCESS HAS REQUESTED TOO MANY RESOURCES BUT THE THEIR ACQUIRING ORDER IS NOT AS SAME AS THEY WERE REQUESTED.
    - COMPETITION OF RESOURCES AMONGS THE PROCESS FOR A SOME RESOURCE AS ITS SCARCE IN AVAILABILITY.
    - IMPROPER SYNCHRONIZATION AND ACCESS TO SHARED RESOURCES
    - COMMUNICATION FAILURES, OVER SHARED RESOURCES OR INCINSISTENT SYSTEM UPDATES.
    - THE CYCLE FORMED IN RESPORCE ALLOCATION GRAPH REPRESENTATION PROCESSESS AND RESOURCES.

## WHY DEADLOCKS OCCUR IN THE DINING PHILOSOPHERS PROBLEM?
IN THE GIVEN PROBLEM OF DINING PHILOSOPHERS, THE SITUATION OF DEADLOCKS CAN POSSIBLY OCCUR FROM THE FOLLOWING CASES:

    - WHEN ALL PHILOSOPHERS PICK UP ONE FORK EACH AND THEN WAIT FOR INFINITE TIME WHEN THEY GO TO PICK UP THE SECOND FORK
    - IF THEY REQUIRE A FORK AND A BOWL TOGETHER, DEADLOCK MAY ARRISE
    - WHEN THE SAME RESOURCE (FORK/BOWL) IS TRIED TO ACCESSED BY THE PHILOSOPHERS.
    - LACK OF CO-ORDINATION AMONGST THE PHILOSOPHERS. THIS CAN LEAD TO A SITUATION OF STARVATION.

## HOW ARE DEADLOCKS AVOIDED IN OUR SOLUTION
IN ORDER TO OVERCOME THE SITUATIONS OF DEADLOCK, THE USD OF FOLLOWING ARE DONE:
    
    - MUTEX LOCKS
    - CONDITIONAL VARIABLES
    - MAINTAINING ORDER OF ALLOCATION OF RESOURCES
    - TRACKING THE AVAILABILITY OF THE RESOURCES
    - RELEASING THE RESOURCES

1. MUTEX LOCKS

    - MUTEX LOCKS LIKE pthread_mutex_lock AND pthread_mutex_unlock ARE USED BY US WHILE SOLVING THE PROBLEM IN ORDER TO ENSURE THE ACCESS TO SECTIONS LIKE state, bowls AND forks.

    - THE MODIFICATION IS PREVENTED

2. CONDITIONAL VARIABLES

    - THE FUNCTIONS pthread_cond_wait AND pthread_cond_signal ARE USED TO MANAGE SYNCHRONIZATION IN THE THREAD.

    - WITH THE HELP OF THE FUNCTION pthread_cond_wait, THE PHILOSOPHER IS MADE TO WAIT FOR THE REQUIRED RESOURCES.

    - WHENEVER THE RESOURCES REQUIRED BY THE PHILOSOPHERS ARE AVAILABLE, THE FUNCTION pthread_cond_signal GIVES A SIGNAL TO THE PHILOSOPHER THAT HAS BEEN ON HALT, TO PROCEED.

3. MAINTAINING ORDER OF ALLOCATION OF RESOURCES

    - A SPECIFIC ORDER IS BEING MAINTAINED IN OBTAINING THE REQUIRED RESOURCES.

    - THIS ALSO ENSURES FAIR ACCESS OF THE RESOURCES FOR ALL PHILOSOPHERS.

4. TRACKING THE AVAILABILITY OF THE RESOURCES

    - WITH THE HELP OF THE "bowls[CENTER_BOWL_1].available" AND "bowls[CENTER_BOWL_2].available", WE ARE ABLE TO TRACK THE AVAILABILITY OF THE BOWLS.

    - THE BOWL IS PICKED ONLY WHEN IT'S AVAILABILITY EXISTS. THIS AVOIDS THE SITUATION OF DEADLOCK WHERE ALL THE BOWLS ARE TAKEN BY THE PHILOSOPHERS.

5. RELEASING THE RESOURCES

    - ONCE THE PHILOSOPHERS ARE DONE USING THE RESOURCES (BOWLS/FORKS), THE return_forks_and_bowl FUNCTION MAKES THE PHILOSOPHERS RELEASE THE ACQUIRED RESOURCES, THUS AVOIDING THE CASE OF DEADLOCK.


## FAIRNESS OF THE SOLUTION
IN ORDER TO CHECK THE FAIRNESS OF OUR CODE i.e. WHICH AND HOW MANY OF THE PHILOSOPHERS WERE ABLE TO EAT & AN ESTIMATE OF HOW OFTEN A PHILOSOPHER IS ABLE TO EAT, WE LET OUR CODE EXECUTE FOR DIFFERENT TIMINGS. THE TIME-STAMPS USED ARE:


##        TIME STAMPS
+-------+---------------------+
|  SNo. |     TIME STAMPS     |
+-------+---------------------+
|   1   |     30 Seconds      |
+-------+---------------------+
|   2   |     1 Minute        | 
+-------+---------------------+
|   3   |     2 Minutes       |
+-------+---------------------+
|   4   |     5 Minutes       |
+-------+---------------------+

## OBSERVATIONS & FAIRNESS EVALUATION
WE HAVE RUN THE PROGRAMS DIFFERENTYLY FOR EACH OF THE TIME STAMPS MENTIONED ABOVE. THE OBSERVATIONS ARE MENTIONED BELOW:

1. OBSERVATIONS

    - Philosopher 0: An unusual routine of thinking and eating.
    - Philosopher 1: Frequently eating, with occasional periods of thought.
    - Philosopher 2: Variable lengths of thought and eating, not regularly frequent.
    - Philosopher 3: An erratic routine of thinking and eating.
    - Philosopher 4: Not as often as Philosopher 1, but rather steady cycles of eating and pondering.

2. FAIRNESS EVALUATION

    - Philosopher 1 appears to have had more eating chances than others, which might be explained by the pattern of longer eating times and shorter pondering stages.
    - Philosophers 0, 3, and 4 ate and thought, but their occurrences were less consistent than philosopher 1.
    - When compared to philosopher 1, philosopher 2 had more irregular intervals between eating and thinking making it less frequent.
